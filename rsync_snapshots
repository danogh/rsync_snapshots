#!/usr/bin/perl

#--------------------------------------------------------------------------
# 
# rsync_snapshots
#
# Create snapshots using rsync.
#
$VERSION="2.00b2";
$RELEASED="Feb  1, 2025";
$GPL=<<"EOGPL";

Copyright (C) 2006,2007,2008,2012,2014,2016,2025 Dan D Niles

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

EOGPL
#
#--------------------------------------------------------------------------
#
# Create snapshots using rsync.
#
# Snapshots will be in directories called snap.<datestamp>.
#
# This script requires a config file, which by default is
# /usr/local/etc/rsync_snapshots.conf.  It can be changed with
# the --conf option.
#
# The config file contains lines like:
#
# rsync_snapshot( <source>, <dest>, <expire> [, <option>=<value>...] );
#
# <source> can be 'host:/path-to-dir/dir/',  'host::module/dir/'
#          or /path-to-dir/dir/.
# -DDN-
# <dest>   can be an absolute or relative path.  If it is a relative
#          path, it is relative to <source>, which must be local.
#          Dest cannot contain a ':'!
# <expire> is when to expire files, or how long to keep snapshots.
#          Snapshots older than this will be removed.
#          The value '0' or 'undef' means keep all snapshots.
#          Otherwise, the value is in seconds or a time string made 
#          up of the following parts (where n is any number):
#
#             ny  n years
#             nM  n Months (n*30 days)
#             nw  n weeks
#             nd  n days
#             nh  n hours
#             nm  n minutes
#             n   n minutes
#
#          The following are all equivalent:
#
#             "1w1d1h", "8d1h", "193h", "11580m", 11580
#
#          NOTE: If expire is not a multiple of one day, datestamps
#                will include an hour and minute. So "7d" (604800s)
#                would not have hour and minute but "7d1" (604860s)
#                would. 
#
# <option> Set various options.  Supported options are:
#
#          exclude=<pat>        Exclude files matching pattern <pat>
#          exclude_from=<file>  Exclude files matching patterns in <file>
#          rsync_opts=<opts>    Override the default rsync options.
#                               (Default is "-xaSH --numeric-ids --delete")
# -DDN-
#          extra_opts=<opts>    Extra options to add to rsync_opts
#
#          NOTE: exclude and exclude_from may be specified more than once.
#
#--------------------------------------------------------------------------

# -DDN-
# Specify location of rsync and find in config file!
# Override location of find in config file!
# Location and options for mail program
# Config file NOT world write (or read?)
# Change opts storage to arrays

use File::Basename;

use strict vars;
use vars qw( $VERSION $RELEASED $GPL $CPR $DSC );
if( $GPL ){ $GPL =~ s/^\s*\n+//; ($CPR,undef,$DSC)=split(/^\s*\n+/m,$GPL); }
use vars qw( $Conf $Max_Delete $Rsync_Opts $LOGFILE );
use vars qw( %Exec  $Quiet);

use vars '$Indent';

# -DDN- Change to /etc/ for Linux?
# Were to find the config file.
$Conf="/usr/local/etc/rsync_snapshots.conf";

# Maximum number of snap directories to delete at one time
$Max_Delete=5;

# Options to use for rsync
$Rsync_Opts="-xaSH --numeric-ids --delete";

# Where to send output when --cron is specified
$LOGFILE="/var/log/rsync_snapshots"; 

use vars qw( $Options $ONL );
$Options=<<'EOF';
  -h, --help               Print help message
  -V, --version            Print version and exit
  -v, --verbose            Be more verbose 
  -q, --quiet              Be quiet (about errors)
  -n, --dry-run            Dont actually copy files, just pretend.
  --cron                   Send output to log file instead of stdout
  -c, --conf=<conf>        Read config from <conf>.$ONL
                           Defaults to /usr/local/etc/rsync_syanpshots.conf$ONL
  -m, --max-delete=n       Delete at most n old snapshots
  -d, --delete-only        Only delete old snapshots, dont do rsyncs
  --errors-to=<email>      Send email of rsync errors to <email>
EOF

use vars qw( $OK $Help $Print_Version $VERBOSE );
use vars qw( $Dry_Run $Quiet $Cron $Conf $Delete_Only );
use vars qw( @Errors $Errors_To );

use Getopt::Long qw(:config gnu_getopt );
$OK=GetOptions("h|help" => \$Help,
	       "V|version" => \$Print_Version,
	       "v|verbose+" => \$VERBOSE,
	       "q|quiet" => \$Quiet,
	       "n|dry-run+" => \$Dry_Run,
	       "cron" => \$Cron,
	       "c|conf=s" => \$Conf,
	       "m|max-delete=i" => \$Max_Delete,
	       "d|delete-only" => \$Delete_Only,
	       "errors-to=s" => \$Errors_To,
	       );

use vars qw( $FullPath );
$FullPath=$0;
$0 =~ s%.*/%%;

sub print_version {
    &pr_info("%s %s\n", $0, $VERSION);
    if( $VERBOSE ){
	&pr_info("$CPR\n");
	&pr_info("$DSC\n");
	&pr_info("Written by Dan D Niles\n");
    }
}
sub print_usage {
    &pr_error("Usage: $0 [options]\n");
}
sub short_help {
    &print_usage();
    &pr_error("Use \'$0 --help\' for detailed help.\n");
} 
sub help {

    if( $VERBOSE ){ $ONL="\n"; }
    &pr_info("Generate snapshot backups using rsync.\n\n");
    &pr_info("Usage: $FullPath [options]\n\n");
    $Options =~ s/\$ONL/\n/g;
    &pr_info("Options:\n$Options\n");

}

# Allowed config file variables
use vars qw( %Allowed_Conf_Opts );
%Allowed_Conf_Opts=(
    Errors_To => 1,
);

&check_args();

if( $Help ){ &help(); exit; }
if( !$OK ){ &short_help(); exit 255; }
if( $Print_Version ){ &print_version(); exit; }

if( $VERBOSE ){
    print "-START- ";
    system("/bin/date");
}

&pr_vvverbose("Reading config file %s\n", $Conf);
package Conf;

# Attempt to prevent mistakes and nefarious actions.
sub not_allowed {
    print main::SAVERR "Use of '@_' in config file not allowed\n";
    exit -1;
};
open CNF, $main::Conf or die("Could not open $main::Conf!"); 
while(<CNF>){ if( m/([*$@%]?(main|CORE)::[[:alnum:]]*)/ ){ &not_allowed("$1"); }}
close CNF;
foreach my $disable (qw( system open sysopen )){
    *{"CORE::GLOBAL::".$disable} = sub { &not_allowed("${disable}()"); };
}
*CORE::GLOBAL::readpipe = sub { &not_allowed("``"); return undef ;};

eval {
    require $main::Conf;
};

package main;
if( $@ ){
    my @errors=grep( ! /Compilation failed in require/, split(/\n+/, $@));
    foreach my $e (@errors){ &pr_error("$e\n"); }
    push(@Errors, @errors);
    &pr_error("ERROR: Errors in config file! Aborting!\n");
    push(@Errors, "Errors in config file! Aborting!");
}elsif( $Conf && &check_conf_vars() ){
    &pr_error("ERROR: Errors in config file! Aborting!\n");
    push(@Errors, "Errors in config file! Aborting!");
}

&email_errors();

if( $VERBOSE ){
    print "-END- ";
    system("/bin/date");
}

if( @Errors ){
    exit -1;
}

exit;

sub check_args
{

    open SAVOUT, ">&STDOUT";
    open SAVERR, ">&STDERR";
    if( $Cron ){
	open STDOUT, ">>$LOGFILE";
	open STDERR, ">&STDOUT";
	$VERBOSE=1 if not $VERBOSE;
	$Quiet=0;
    }

    if( ! -f $Conf && ! $Help && ! $Print_Version ){
	print STDERR "ERROR: Cannot open config file: '$Conf'\n";
	$OK=0;
    }
    if( $Conf !~ m%^/% ){ $Conf = "$ENV{PWD}/$Conf"; }

    if( $Dry_Run && !$VERBOSE ){
	$VERBOSE=1;
    }

    if( !$Exec{rsync} ){ 
	if( -x "/usr/bin/which" ){
	    chomp($Exec{rsync}=`/usr/bin/which rsync`);
	}
	if( !$Exec{rsync} ){
	    if( -x "/usr/bin/rsync" ){
		$Exec{rsync}="/usr/bin/rsync"; 
	    }elsif(-x "/usr/local/bin/rsync" ){
		$Exec{rsync}="/usr/local/bin/rsync";
	    }else{
		print STDERR "ERROR: Cannot locate rsync\n";
		$OK=0;
	    }
	}
    }

    return;
}

sub email_errors ()
{
    if( $Errors_To && @Errors ){
	unless($Exec{mailx}){ $Exec{mailx}="mailx"; }
	open( MAIL, "|$Exec{mailx} -s 'rsync_snapshots FAILED!' $Errors_To");
	foreach my $err (@Errors){
	    print MAIL $err;
	    if( $err !~ m/\n/ ){
		print MAIL "\n";
	    }
	}
	close MAIL;
    }
}

exit; 

sub Conf::rsync_snapshot ($$@)
{
    my($src)=shift;
    my($dst)=shift;
    my($expire)=shift;
    my(%Opts);

    #my $rdest="";
    #my $rfile="";

    if( $Conf && &check_conf_vars() ){
	&pr_error("ERROR: Errors in config file! Aborting!\n");
	push(@Errors, "Errors in config file! Aborting!");
	&email_errors();
	exit -1;
    }

    &pr_vvverbose("rsync_snapshot(%s,%s,%s,%s);\n",
		  $src, $dst, $expire, join(",", @_));

    foreach ( @_ ){
	if( m/=/ ){
	    my($var,$val)=split(/\s*=\s*/);
	    if( !$val ){
		&pr_error("Error: Missing value for option %s to rsync_snapshot.\n", $var);
		&pr_error("Skipping %s\n", $src);
		return -1;
	    }
	    if( $var eq "exclude" ||
		$var eq "exclude_from" ){
		$Opts{$var}.="$val,";
	    }
	    elsif( $var eq "rsync_opts" ){
		$Opts{$var}=$val;
	    }else{
		&pr_error("Error: Unknown option %s to rsync_snapshot.\n",
			  $var);
		&pr_error("Skipping %s\n", $src);
		return -1;
	    }
	}
	elsif( $_ ){
	    &pr_error("Error: Unknown option %s to rsync_snapshot.\n", $_);
	    &pr_error("Skipping %s\n", $src);
	    return -1;
	}
    }

    # -DDN- I already forgot why I wanted/need the user vars
    my( $src_user, $dst_user );
    my( $src_host, $src_file, $dst_host, $dst_dir );
    my($last_snap,$datestamp,$timestamp);
    my($exclude, @command);
    
    # Remove double / and final / from paths
    $src =~ s%//+%/%; $src =~ s%/+$%% unless $src eq "/";
    $dst =~ s%//+%/%; $dst =~ s%/+$%% unless $dst eq "/";

    if( $src eq $dst ){
	&pr_error("ERROR: %s: source and dest cannot be the same!\n", $src);
	&pr_error("       Skipping %s\n", $src);
	return -1;
    }

    if( $src =~ m/::/ ){
	# This is an rsyncd source!
	($src_host, $src_file)=split(/::/, $src, 2);
	if( $src_file !~ m%^/% ){
	    $src_file="/$src_file";
	}
    }
    elsif( $src =~ m/:/ ){
	# This is a remote src host!
	($src_host, $src_file)=split(/:/, $src, 2);
    }else{
	$src_file=$src;
    }
	    
    if( $src_file !~ m%^/% ){
	&pr_error("ERROR: %s: Source must be an absolute path!\n", $src_file);
	&pr_error("       Skipping %s\n", $src);
	return -1;
    }

    if( $dst =~ m/::/ ){
	# This is an rsyncd destination!
	&pr_error("ERROR: Destination CANNOT use rsyncd! (NO \'::\' in dest!)\n");
	&pr_error("       Skipping %s\n", $src);
	return -1;
    }
    elsif( $dst =~ m/:/ ){
	($dst_host, $dst_dir)=split(/:/, $dst, 2);
    }
    else{
	$dst_dir=$dst;
    }
	
    # If $dst_dir and src_dir are local then $dst_dir can be
    # relative. -DDN-
    
    if( $src_host && $dst_host ){
	&pr_error("ERROR: source and dest cannot both be remote!\n");
	&pr_error("       Skipping %s!\n", $src);
	return -1;
    }
    elsif( $src_host && $dst_dir !~ m%^/% ){
	&pr_error("ERROR: local dest must be absolute path with remote source!");
	&pr_error("       Skipping %s!\n", $src);
	return -1;
    }
    # -DDN- HERE
    
    # -DDN-
    # src_file can be relative if remote! name@host:. to snapshot homedir!

    # -DDN-
    if( !$src_host && !$dst_host ){
	# Both are local
	if( $dst_dir =~ m%^/% ){
	    if( $dst_dir =~ m%^$src_file/% ){
		$exclude=$dst_dir;
		$exclude =~ s%^$src_file/%/%;
	    }
	}
	else{
	    $exclude="/$dst_dir";
	    $dst_dir="$src_file/$dst_dir";
	    $dst=$dst_dir;
	}
	if( ! -d $dst_dir ){
	    &pr_error("ERROR: destination dir %s does not exist, but must!\n", $dst_dir);
	    &pr_error("       Skipping %s\n", $src);
	    return -1;
	}

    }
    elsif( $src_host && !$dst_host ){
	if( $dst_dir !~ m%^/% ){
	    &pr_error("ERROR: local dest must be absolute path with remote source!");
	    &pr_error("       Skipping %s!\n", $src);
	    return -1;
	}
	
    }
    elsif( !$src_host && $dst_host ){
	# Might consider allowing remote dest to be relative to login dir.
	if( $dst_dir !~ m%/% ){
	    &pr_error("ERROR: remote dest must be an absolute path!");
	    &pr_error("       Skipping %s!\n", $src);
	    return -1;
	}
	if( system("ssh $dst_host ls -d /tmp >/dev/null 2>&1") ){
	    &pr_error("ERROR: Unable to ssh to remote dest %s, which is required!\n", $dst_host);
	    &pr_error("       Skipping %s!\n", $src);
	    return -1;
	}
	if( system("ssh $dst_host test -d $dst_dir") ){
	    &pr_error("ERROR: destination dir %s:%s does not exist, but must!\n", $dst_host,$dst_dir);
	    &pr_error("       Skipping %s\n", $src);
	    return -1;
	}
    }
    else{
	# Both are remote, should not have make it here!
	&pr_error("ERROR: source and dest cannot both be remote!\n");
	&pr_error("       Skipping %s!\n", $src);
	return -1;
    }
    
    &to_seconds($expire);
    if( @Errors ){ return -1; }

    if( $Delete_Only ){
	&purge_old_snaps($dst, $expire);
	return 1;
    }

    $last_snap=&list_datestamps("$dst/snap", 1, 1);
    &pr_vverbose("Last snapshot: %s\n", $last_snap?$last_snap:"none");
    $datestamp=&gen_datestamp();

    if( ($expire && ( &to_seconds($expire)%&to_seconds("1d") ||
	   ( $last_snap && $last_snap =~ m/$datestamp$/ )))){
	$timestamp=1;
    }

    push @command, $Exec{rsync};

    if( $Dry_Run == 1 ){
	push @command, "-n";
    }

    if( $Cron ){
	push @command, "--stats";
    }else{
	if( $VERBOSE > 1 ){
	    if( $VERBOSE > 2 ){
		push @command, "-vP";
	    }else{
		push @command, "-v";
	    }
	}
	if( $Quiet ){
	    push @command, "-q";
	}
    }

    if( $Opts{rsync_opts} ){
	push @command, split(/\s+/, $Opts{rsync_opts});
    }else{
	push @command, split(/\s+/, $Rsync_Opts);
    }

    # Exclude snapshot directories from other systems
    push @command, "--exclude=.snap";
    push @command, "--exclude=.zfs";

    if( $exclude ){
	push @command, "--exclude=$exclude";
    }

    if( $Opts{exclude} ){
	foreach my $exclude (split(/,/, $Opts{exclude})) {
	    push @command, "--exclude=$exclude";
	}
    }

    if( $Opts{exclude_from} ){
	foreach my $exclude_from (split(/,/, $Opts{exclude_from})) {
	    if( $exclude_from && ! -f $exclude_from ){
		&pr_error("ERROR: Exclude file '%s' not found!\n", $exclude_from);
		&pr_error("       Skipping '%s'\n", $src);
		return -1;
	    }

	    push @command, "--exclude-from=$exclude_from";
	}
    }

    if( $last_snap ){
	if( $dst_host && !system("ssh $dst_host test -d $last_snap") ){
	    push @command, "--link-dest=$last_snap";
	}
	elsif( -d $last_snap ){
	    push @command, "--link-dest=$last_snap";
	}
    }

    push @command, $src eq "/"?"$src":"$src/";

    my $snap_dir= sprintf("%s/snap.%s",$dst_dir, &gen_datestamp(0,$timestamp));
    if( $dst_host ){
	if( ! system("ssh $dst_host test -d $snap_dir 2>/dev/null") ){
	    my($i)=1;
	    while( ! system("ssh $dst_host test -d $snap_dir.$i 2>/dev/null") ){
		$i++;
	    }
	    $snap_dir.=".$i";
	}
    }
    elsif( -d $snap_dir ){
	my($i)=1;
	while( -d "$snap_dir.$i" ){
	    $i++;
	}
	$snap_dir.=".$i";
    }

    if( $dst_host ){
	push @command, "$dst_host:$snap_dir/";
    }else{
	push @command, "$snap_dir/";
    }

    printf("--xfer begin-- %s\n", scalar localtime(time)) if $VERBOSE;
    print join " ", @command if $VERBOSE; print "\n" if $VERBOSE;

    my $ret=system( @command ) unless $Dry_Run > 1 ;

    printf("--xfer end-- %s\n", scalar localtime(time)) if $VERBOSE;

    if( $ret && ($ret/256 != 24) ){
	&pr_error("Error: rsync failed (err %d) for %s -> %s\n", int($ret/256), $src, $dst);
	push(@Errors, sprintf("Rsync failed (err %d) for %s -> %s\n",
			      int($ret/256), $src, $dst));
	if( $Cron ){
	    my(@errors)=();
	    unless( open LOGF, "$LOGFILE" ){
		printf SAVERR "Cannot open log file %s (%s)\n", $LOGFILE, $?;
	    }
	    while(<LOGF>){
		if( /^-START-/ ){
		    @errors=();
		    next;
		}
		if( /rsync error:/ ){
		    push @errors, $_;
		}
	    }
	    close LOGF;
	    push @Errors, @errors;
	    push @Errors, "\n";
	}
    }else{
	&purge_old_snaps($dst, $expire);
    }

    if( $ret ){ return 0; }

    return 1;
}

sub purge_old_snaps ( $:$ )
{

    my($dst)=shift;
    my($expire)=shift;
    my($delete);

    &pr_vvverbose("purge_old_snaps(%s,%s);\n", $dst, $expire);

    if( ! $expire ){ return 1; }

    my(@files)=&list_old_datestamps("$dst/snap", $expire);
    &pr_vvverbose("\@files=[ %s ]\n", join(", ", @files));

    my $rdest="";
    if( $dst =~ s/^(.*?):(.*)// ){
	$rdest=$1;
    }
    foreach my $file (@files){
	if( $Max_Delete >= 0 && ++$delete > $Max_Delete ){
	    printf STDERR ("Warning: Would be deleting more than %s\n",
			   $Max_Delete);
	    printf STDERR ("         snap directories! Not deleting any more!\n");
	    last;
	}
	my @command;
	if( $rdest ){
	    push(@command, "ssh $rdest");
	}
	push(@command,"/bin/rm -rf $file");
	printf("%s\n",  join " ", @command ) if $VERBOSE;
	system(@command) unless $Dry_Run;
    }

    return 1;
}

exit;

sub check_conf_vars
{
    my($err)=0;
    foreach my $name (sort keys %Conf::){
	local *main::sym = $Conf::{$name};
	if( defined($main::sym) ){
	    if( $Allowed_Conf_Opts{$name} ){
		next;
	    }
	    # -DDN-
	    #if( $name eq "Errors_To" ){
		#next;
	    #}
	    push(@Errors, sprintf("Unknown config variable \$%s\n", $name));
	    printf SAVERR "ERROR: Unknown config variable \$%s\n", $name;
	    $err=1;
	}
	if( @main::sym ){
	    push(@Errors, sprintf("Unknown config variable \@%s\n", $name));
	    printf SAVERR "ERROR: Unknown config variable \@%s\n", $name;
	    $err=1;
	}
	if( %main::sym ){
	    push(@Errors, sprintf("Unknown config variable %%%s\n", $name));
	    printf SAVERR "ERROR: Unknown config variable %%%s\n", $name;
	    $err=1;
	}
    }

    foreach my $v (keys %Allowed_Conf_Opts){
	if( ${"Conf::".$v} && !defined(${"main::".$v}) ){
	    ${"main::".$v}=${"Conf::".$v}; 
	}
    }

    return $err;
}
#exit;
# Start of datestamps.pl
#
# Version 1.0
# Released 8/2/7

sub gen_datestamp (:$$)
{
    my($time)=shift;
    my($tod)=shift; # Add time of day to datestamp?
    my(@now, $ext);

    if( $time ){
	@now=localtime($time);
    }else{
	@now=localtime(time);
    }

    $ext=sprintf("%04d%02d%02d", $now[5]+1900,, $now[4]+1, $now[3]);

    if( $tod ){
	$ext.=sprintf("_%02d%02d", $now[2], $now[1]);
    }
    
    return $ext;
}

# -DDN- This needs to be adjusted. $age doesn't work with short
#       durations (used in testing mostly)
# -DDN- Also, what does $time do?
# list_datestamps( $file [, $num [, $reverse [, $age [, $time]]]] );
#
# Return array of file names.
# In a scalar context, it returns a string listing all the files.
sub list_datestamps ( $:$$$$ )
{
    my($file)=shift;
    my($num)=shift;     # Only list this many files (0 means all);
    my($reverse)=shift; # Reverse the order?
    my($age)=shift;     # list files older than this many seconds
    my($time)=shift;    # based on this time.
    
    my($command);
    my($target_day,$target_time,$count);
    my(@files,@result);

    &pr_vvverbose("list_datestamps(%s,%s,%s,%s,%s);\n",
		  $file, $num,$reverse,$age,$time);

    my $rdest="";
    if( $file =~ s/^(.*?):(.*)// ){
	$rdest=$1;
	$file=$2;
    }

    $file=~ s%//%/%g;
    my($name,$dir)=fileparse($file);

    if( $age ){
	if(!$time){ $time=time; }
	my $target=&gen_datestamp($time-&to_seconds($age), 1);
	$target =~ m/(\d+)_(\d+)/;
	$target_day = $1;
	$target_time = $2;
    }

    unless($Exec{find}){ $Exec{find}="find"; }
    if( $rdest ){
	$command="ssh $rdest $Exec{find} $dir -maxdepth 1 -name \"$name.*\"";
    }else{
	$command="$Exec{find} $dir -maxdepth 1 -name \"$name.*\"";
    }

    printf("%s\n", $command) if $VERBOSE > 1;

    chomp(@files=`$command`);
    printf("%s\n", join("\n",@files)) if $VERBOSE > 1;

    if( $reverse ){
	@files = reverse sort @files;
    }else{
	@files = sort @files;
    }

    $count=0;
    foreach(@files){
	if( m/\.(\d{8})(_(\d{4}))?(\.\d+)?(\.\w+)?$/ ){
	    my $fday = $1;
	    my $ftime = $3;
	    if( $age ){
		if( $fday lt $target_day ||
		    ( $fday eq $target_day &&
		      $ftime lt $target_time ) ){
		    push(@result, $_);
		    if( $num && ++$count >= $num ){
			last;
		    }
		}
	    }else{
		push(@result, $_);
		if( $num && ++$count >= $num ){
		    last;
		}
	    }
	}else{
	    printf( STDERR "Warning: Ignoring unknown file: %s\n", $_) 
		unless $Quiet;
	}
    }

    if( wantarray ){
	return  @result ;
    }else{
	return join(", ", @result);
    }
}

sub list_old_datestamps($:$$$)
{
    my($file)=shift;
    my($age)=shift;     # list files older than this many seconds
    my($time)=shift;    # based on this time.
    my($num)=shift;     # Return at most $num files;

    &pr_vvverbose("list_old_datestamps(%s,%s,%s,%s);\n",
		  $file, $age, $time, $num);

    return &list_datestamps($file,$num,0,$age,$time);
}
sub list_new_datestamps($$:$$)
{
    my($file)=shift;
    my($age)=shift;     # list files older than this many seconds
    my($time)=shift;    # based on this time.
    my($num)=shift;     # Return at most $num files;

    &pr_vvverbose("list_new(%s,%s,%s,%s);\n",
		  $file, $age, $time, $num);

    return &list_datestamps($file,$num,1,$age,$time);
}

sub to_seconds ($)
{
    my($t)=shift;
    my($time)=$t;
    my($result)=0;

    if( $time =~ s/(\d+)m// ){ $result+=$1*60; }
    if( $time =~ s/(\d+)h// ){ $result+=$1*60*60; }
    if( $time =~ s/(\d+)d// ){ $result+=$1*24*60*60; }
    if( $time =~ s/(\d+)w// ){ $result+=$1*7*24*60*60; }
    if( $time =~ s/(\d+)M// ){ $result+=$1*30*24*60*60; }
    if( $time =~ s/(\d+)y// ){ $result+=$1*366*24*60*60; }
    if( $time =~ s/^(\d+)$// ){ $result+=$1*60; }
    elsif( $time ){
	&pr_error("ERROR: Ignoring unknown time format: %s\n",$t) 
	    unless $Quiet;
    }

    return $result;
}

# End of datestamps.pl
1;
#exit;
# Start of print.pl
#

sub pr_info
{
    my($fmt)=shift;

    printf( $fmt, @_ );
    return 1;
}

sub pr_error
{
    my($fmt)=shift;

    printf( STDERR $fmt, @_ );
    push(@Errors, sprintf( $fmt, @_ ));
    return 1;
}

sub pr_warn
{
    my($fmt)=shift;

    printf( STDERR $fmt, @_ );
    return 1;
}

sub pr_verbose
{
    my($fmt)=shift;

    return 0 unless $VERBOSE;

    printf( "%s", $Indent) if $Indent;
    printf( $fmt, @_ );
    return 1;
}

sub pr_vverbose
{
    my($fmt)=shift;

    return 0 unless $VERBOSE > 1;

    printf( "%s", $Indent) if $Indent;
    printf( $fmt, @_ );
    return 1;
}

sub pr_vvverbose
{
    my($fmt)=shift;

    return 0 unless $VERBOSE > 2;

    printf( "%s", $Indent) if $Indent;
    printf( $fmt, @_ );
    return 1;
}

# End of print.pl
1;
